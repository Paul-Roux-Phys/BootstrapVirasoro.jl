var documenterSearchIndex = {"docs":
[{"location":"public_api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"bootstrapeqs/#Solving-bootstrap-equations","page":"Bootstrap equations","title":"Solving bootstrap equations","text":"The package provides functionality to create and solve linear systems of bootstrap equations.\n\nusing BootstrapVirasoro\n\n# set the precision of high-precision floats\nsetprecision(BigFloat, 40, base=10)\n\nβ    = big\"0.3\" + big\"0.6\"*im\n# define a central charge\nc    = CC(β = β)\n\nV12  = Field(c, r=1, s=2, diagonal=true) # the external, degenerate field\nP    = big\"0.67\"\nVP   = Field(c, P=P) # the external diagonal field\nVPpm = [Field(c, P = P + pm*1/(2β)) for pm in (-1, 1)] # shifted fields\nVd   = [Field(c, r=1, s=1, diagonal=true),\n        Field(c, r=1, s=3, diagonal=true),\n        Field(c, r=1, s=5, diagonal=true)] # degenerate fields\n# list of all fields that can go in channels (vcat concatenates vectors.)\nV    = vcat(VPpm, Vd) \n\nCor  = Correlation(V12, VP, V12, VP, 70) # define the correlation\n\n# We need to define ChannelSpectrum objects for each channel.\n# They are created as ChannelSpectrum(correlation, channel, listoffields, function)\n# where the function is a function that takes as input a field and outputs a block object.\nfs(V) = NCBlock(Cor, :s, V) # map fields to blocks\nCs    = ChannelSpectrum(Cor, :s, V, fs) # create s-channel spectrum\nft(V) = NCBlock(Cor, :t, V)\nCt    = ChannelSpectrum(Cor, :t, V, ft) # t-channel\nfu(V) = NCBlock(Cor, :u, V)\nCu    = ChannelSpectrum(Cor, :u, V, fu) # u-channel\n\nsol = solve_bootstrap(Channels(Cs, Ct, Cu)) # setup and solve the crossing equations\nsol.str_cst # return the structure constants\n\n# you can display the structure constants with\n# println(sol.str_cst)\n# or\n# show(stdout, sol.str_cst)\n# changing stdout to a file IO will print to a file instead.\n\nThe output of running this code should be a colored table indicating the values of the structure constants, and an estimation of the numerical error. You can see this output in the jupyter notebook on the github repo.","category":"section"},{"location":"conformalblocks/#Computing-conformal-blocks","page":"Conformal blocks","title":"Computing conformal blocks","text":"The library uses the Zamolodchikov recursion to compute four-point conformal blocks on the sphere, and one-point conformal blocks on the torus.\n\nSince the library is optimized for bootstrap computations in arbitrary precision, it caches any intermediary computations that can be reused. To this end, we use several types, each storing its own cache: CentralCharge, ConformalDimension, Field, Correlation, Block.\n\nusing BootstrapVirasoro\n\n# set the precision of high-precision floats\nsetprecision(BigFloat, 30, base=10)\n\n# Define a high precision number (BigFloat type) from float literals:\nβ = big\"0.3\" + big\"0.6\"*im\n\n# Define a corresponding central charge\nc = CC(β = β)\n\n# Define ConformalDimension objects.\nD1 = CD(c, P = big\"1.2\")\nD2 = CD(c, r = 2, s = 1//2) # a // b is the Julia syntax for rational numbers.\n# we can use regular floats as well, but beware that the will not be correctly rounded\n# when they are converted to a BigFloat type.\nD3 = CD(c, P=1.2) # D3 not strictly equal to D2.\n\n# Define Field objects.\nV1 = Field(c, P = big\"1\" + big\"0.8\"*im)           # diagonal field of momentum P\nVΔ = Field(c, Δ = big\"0.4\" + big\"0.3\"*im)         # diagonal field of conformal dimension Δ\nV2 = Field(c, r = 2 , s= 1//2)                    # non-diagonal field defined from Kac indices\nV2diag = Field(c, r = 2 , s= 1//2, diagonal=true) # we can force the field to be diagonal\nV3 = Field(c, r = 2, s = 1, diagonal = true)      # degenerate field\nV4 = Field(D1, D2)                                # define a field from a pair of conformal dimensions\nV2.dims                                           # inspect left and right conformal dimensions\nV2.dims.left\nswap_lr(V2)                                       # swap the left and right conformal dimensions (space parity)\nswap_lr(V4)\n\n#=\ndefine a correlation with Correlation(fields, Nmax)\nThis precomputes the coefficients R_mn that are the residues of conformal blocks\nfor this correlation, up to m * n = Nmax,\nand also the coefficients C^N_mn obtained by solving the\nZamolodchikov recursion relation. =#\n\n# non-chiral, four-point\nCor = Correlation(V1, V1, V1, V1, 20)\n# chiral, four-point\nbndrycor = Correlation(D1, D1, D1, D1, 20)\n# non-chiral, one-point (torus)\ntoruscor = Correlation(V1, 20)\n\nbndrycor.Rmn.s[2, 1] # the correlation stores the value of Rmn, which can be inspected\n\n# define a non-chiral s-channel block. This stores the series coefficients\nb4 = NCBlock(Cor, :s, V4)\nb2 = NCBlock(Cor, :s, V2)\n# evaluate the block at a value of the cross-ratio z\nb4(0.95 + 2.04im)\n\n# define a chiral s-channel block\nbndry = CBlock(bndrycor, :s, D2)\nx = big\"0.84\"+big\"0.3\"*im\n# evaluate it at a position\n@time bndry(x)\n\n# we can linearly combine block and easily evaluate the linear combination\n# the first argument is a list of blocks, the second argument a list of coefficients\n# here we compute 2 b2 + 3 b4.\nLc = LinearCombinationBlock([b2, b4], [2, 3])\n# evaluate\nLc(big\"1\"+big\"1\"*im)\n\n# when evaluating many blocks at the same position, we can compute once and for all\n# all the data about the positions that is common to all blocks, i.e. the nome q, powers\n# of q, and the prefactors x^E1 (1-x)^E3 theta_3(q)^E_4. The evaluation of the blocks is\n# several orders of magnitude faster if we input the cache instead of the raw position.\n# the cache is created with BootstrapVirasoro.PosCache.\ncache = BootstrapVirasoro.PosCache(x, bndrycor.fields, :s, 20)\n@time bndry(cache)","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"To install this package, run\n\nusing Pkg; Pkg.add(url=\"add https://github.com/Paul-Roux-Phys/BootstrapVirasoro.jl.git\")\n\nin a Julia REPL or script, or from a julia REPL type ] to enter Julia's package manager and run\n\n(your_environment)> add https://github.com/Paul-Roux-Phys/BootstrapVirasoro.jl.git\n\nTo bring the functions exported by the package into your current scope, you then need to do\n\nusing BootstrapVirasoro","category":"section"},{"location":"#BootstrapVirasoro.jl-documentation","page":"Home","title":"BootstrapVirasoro.jl documentation","text":"This is the documentation page for the BootstrapVirasoro package. BootstrapVirasoro is a package for doing bootstrap computations in theories with Virasoro symmetry.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Installation\n\nFor any new user, we advise taking a look at the two following files, which contain simple self-contained code examples:\n\ncompute blocks: learn how to compute various types of virasoro conformal blocks,\nsolve bootstrap equations: learn how to use the package's utilities to solve bootstrap equations and pretty-print their solutions.\n\nFor more detailed documentation of the public API of the package, refer to \n\npublic API","category":"section"}]
}
